"""Requests toolkit."""
from __future__ import annotations
import ast
from functools import partial
import inspect
import re

from typing import Any, Callable, List, Sequence, TypeVar

from pydantic import BaseModel

from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.base import BaseToolkit
from langchain.agents.agent_toolkits.json.base import create_json_agent
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.agent_toolkits.openapi.prompt import DESCRIPTION
from langchain.agents.tools import Tool
from langchain.llms.base import BaseLLM
from langchain.requests import RequestsWrapper
from langchain.tools import BaseTool
from langchain.tools.json.tool import JsonSpec
from langchain.tools.requests.tool import (
    RequestsDeleteTool,
    RequestsGetTool,
    RequestsPatchTool,
    RequestsPostTool,
    RequestsPutTool,
)
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Optional, Union
import yaml
import json
from openapi_python_generator.generate_data import (
    HTTPLibrary,
    ConversionResult,
    generator,
    write_data,
    library_config_dict,
    get_open_api,
)
import importlib
from typing import Dict, Set, Tuple, cast


class RequestsToolkit(BaseToolkit):
    """Toolkit for making requests."""

    requests_wrapper: RequestsWrapper

    def get_tools(self) -> List[BaseTool]:
        """Return a list of tools."""
        return [
            RequestsGetTool(requests_wrapper=self.requests_wrapper),
            RequestsPostTool(requests_wrapper=self.requests_wrapper),
            RequestsPatchTool(requests_wrapper=self.requests_wrapper),
            RequestsPutTool(requests_wrapper=self.requests_wrapper),
            RequestsDeleteTool(requests_wrapper=self.requests_wrapper),
        ]


class OpenAPIToolkit(BaseToolkit):
    """Toolkit for interacting with a OpenAPI api."""

    json_agent: AgentExecutor
    requests_wrapper: RequestsWrapper

    def get_tools(self) -> List[BaseTool]:
        """Get the tools in the toolkit."""
        json_agent_tool = Tool(
            name="json_explorer",
            func=self.json_agent.run,
            description=DESCRIPTION,
        )
        request_toolkit = RequestsToolkit(requests_wrapper=self.requests_wrapper)
        return [*request_toolkit.get_tools(), json_agent_tool]

    @classmethod
    def from_llm(
        cls,
        llm: BaseLLM,
        json_spec: JsonSpec,
        requests_wrapper: RequestsWrapper,
        **kwargs: Any,
    ) -> OpenAPIToolkit:
        """Create json agent from llm, then initialize."""
        json_agent = create_json_agent(llm, JsonToolkit(spec=json_spec), **kwargs)
        return cls(json_agent=json_agent, requests_wrapper=requests_wrapper)


class _APIConfigStub:
    """Typing stub for the autogenerated APIConfig."""

    @staticmethod
    def get_access_token() -> Optional[str]:
        pass

    @staticmethod
    def set_access_token(value: str):
        pass


T = TypeVar("T")


class OpenAPIToolkitV2(BaseToolkit):
    """Toolkit for interacting with a OpenAPI api via generated python classes."""

    code_dir: str
    models: Dict[str, BaseModel]
    tools: Sequence[Tool]
    api_config: _APIConfigStub  # :private:

    def get_tools(self) -> List[BaseTool]:
        """Get the tools in the toolkit."""
        json_agent_tool = Tool(
            name="json_explorer",
            func=self.json_agent.run,
            description=DESCRIPTION,
        )
        request_toolkit = RequestsToolkit(requests_wrapper=self.requests_wrapper)
        return [*request_toolkit.get_tools(), json_agent_tool]

    @staticmethod
    def _generate_data(
        source: Union[str, Path],
        output: Union[str, Path],
        library: Optional[HTTPLibrary] = HTTPLibrary.httpx,
        env_token_name: Optional[str] = None,
        use_orjson: bool = False,
    ) -> ConversionResult:
        """
        Generate Python code from an OpenAPI 3.0 specification.
        """
        data = get_open_api(source)
        result = generator(
            data, library_config_dict[library], env_token_name, use_orjson
        )
        write_data(result, output)
        return result

    @staticmethod
    def _generate_client(f_name: Union[str, Path], out_dir: str) -> ConversionResult:
        """Generate a python client from the openapispec.

        Args:
            f_name (str): The name of the spec file. This can
                be a yaml or json file.
            out_dir (str): The output directory.
        Returns:
            The openAPI spec.
        """
        path = Path(f_name)
        if path.suffix == ".json":
            return OpenAPIToolkitV2.generate_data(f_name, out_dir)
            # return get_open_api(f_name)
        if path.suffix in (".yaml", ".yml"):
            # Client generator only supports .json input
            with path.open("r") as f:
                spec = yaml.load(f, Loader=yaml.SafeLoader)
            with TemporaryDirectory() as tmp_dir:
                temp_path = Path(tmp_dir) / "spec.json"
                with temp_path.open("w") as f:
                    json.dump(spec, f)
                return OpenAPIToolkitV2.generate_data(temp_path, out_dir)
        else:
            raise ValueError(f"Unsupported file type: {f_name}")

    @staticmethod
    def _get_openapi_models(
        autogen_package_name: str, valid_model_names: Set[str]
    ) -> Dict[str, BaseModel]:
        """Return the request models from the autogenerated python Client.

        Args:
            autogen_package_name (str): The name of the autogen package.
        """
        # Models are all subclasses of a pydantic BaseModel. E.g., class CreateImageVariationRequest(BaseModel):
        # check if attribute i sa class at all
        models_package = importlib.import_module(f"{autogen_package_name}.models")
        models = []
        for m in dir(models_package):
            if m not in valid_model_names:
                continue
            model_attr = getattr(models_package, m)
            if not isinstance(model_attr, type) or not issubclass(
                model_attr, BaseModel
            ):
                raise ValueError(f"{m} is not a valid model")
            models.append(model_attr)
        return {model.__name__: model for model in models}

    @staticmethod
    def _get_openapi_operations(
        package_name: str,
        valid_operation_names: Set[str],
        service_file_names: List[str],
    ) -> Tuple[Dict[str, Callable], Dict[str, Callable]]:
        """Return the list of endpoints for the autogenerated python Client.

        Args:
            package_name (str): The name of the autogen package.
        """
        # Services are all subclasses of a pydantic BaseModel. E.g., class CreateImageVariationRequest(BaseModel):
        # check if attribute i sa class at all
        async_services = {}
        sync_services = {}
        for file_name in service_file_names:
            which_service = (
                async_services if file_name.startswith("async") else sync_services
            )
            service_module = importlib.import_module(
                f"{package_name}.services.{file_name}"
            )
            for m in dir(service_module):
                if m not in valid_operation_names:
                    # print(f"{m} is not a valid service")
                    continue
                maybe_service = getattr(service_module, m)
                # Only return functions
                if not isinstance(maybe_service, Callable):
                    raise ValueError(f"{m} is not a valid service")
                which_service[maybe_service.__name__] = maybe_service
        return sync_services, async_services

    @staticmethod
    def _get_api_config(package_name: str) -> _APIConfigStub:
        """Return the _APIConfigStub for the autogenerated python Client.

        Args:
            package_name (str): The name of the autogen package.
        """
        # Models are all subclasses of a pydantic BaseModel. E.g., class CreateImageVariationRequest(BaseModel):
        # check if attribute i sa class at all
        autogen_package = importlib.import_module(f"{package_name}.api_config")
        config = cast(_APIConfigStub, autogen_package.APIConfig)
        # See fix: https://github.com/MarcoMuellner/openapi-python-generator/pull/19
        config.set_access_token = lambda x: setattr(config, "_access_token", x)
        return config

    @staticmethod
    def _preprocess_str(
        argument_input: str,
        signature: inspect.Signature,
        param_models: Dict[str, BaseModel],
        func_name: str,
    ) -> Any:
        """Convert the input string to one more more python arguments to be passed to func."""
        if len(signature.parameters) == 0:
            return None
        if len(signature.parameters) == 1:
            # Check if argument_input is passed using a keyword_argument
            parameter_name, parameter = list(signature.parameters.items())[0]
            if re.match(f"^[ ]*{parameter_name}[ ]*=", argument_input):
                argument_input = argument_input.split("=", 1)[1].strip()
            if parameter_name in param_models:
                return param_models[parameter_name].parse_raw(argument_input)
            parameter_type = parameter.annotation
            if parameter_type in (str, int, float):
                return parameter_type(argument_input)
            if parameter_type == bool:
                return argument_input.lower() == "true"
            if parameter_type in (list, dict, tuple):
                return ast.literal_eval(argument_input)
            raise NotImplementedError(f"Unsupported parameter type: {parameter_type}")
        else:
            raise ValueError(f"Function {func_name} has more than one parameter")

    @staticmethod
    def _get_valid_request_models(
        signature: inspect.Signature,
        models: Dict[str, BaseModel],
    ) -> Dict[str, BaseModel]:
        """Return a dictionary of valid request models."""
        return {
            param_name: parameter.annotation
            for param_name, parameter in signature.parameters.items()
            if getattr(parameter.annotation, "__name__", None) in models
        }

    @staticmethod
    def _get_str_preprocessor(
        func: Callable[[T], Any],
        models: Dict[str, BaseModel],
    ) -> Callable[[T], str]:
        """Return a preprocessor that converts a function's inputs into a string."""
        signature = inspect.signature(func)
        valid_models = OpenAPIToolkitV2._get_valid_request_models(signature, models)
        return partial(
            OpenAPIToolkitV2._preprocess_str,
            signature=signature,
            param_models=valid_models,
            func_name=func.__name__,
        )

    @staticmethod
    def get_model_init_signature(model: BaseModel) -> Dict[str, Any]:
        """Convert a schema dict to a simple dictionary of types."""
        schema = model.schema()
        required = set(schema.get("required", []))
        properties = {
            k: v["type"] if k in required else f"Optional[{v['type']}]"
            for k, v in schema["properties"].items()
        }
        return properties

    @staticmethod
    def _get_signature_str(
        func: Callable[[T], Any],
        models: Dict[str, BaseModel],
    ) -> str:
        """Return a string representation of the function signature."""
        signature = inspect.signature(func)
        valid_models = OpenAPIToolkitV2._get_valid_request_models(signature, models)
        # For each parameter, we want to add a new line to the "Args: " description
        # in docstring format.
        param_strs = []
        for param_name, parameter in signature.parameters.items():
            if param_name in valid_models:
                param_strs.append(
                    f"{param_name}: {OpenAPIToolkitV2.get_model_init_signature(valid_models[param_name])}"
                )
            else:
                param_strs.append(f"{param_name}: {parameter.annotation.__name__}")
        return str(signature)

    @staticmethod
    def _get_composed_function(
        preprocessor: Callable,
        fn: Callable,
    ):
        """Return a composed function."""
        return lambda str_: str(fn(preprocessor(str_)))

    @staticmethod
    def _get_tools_from_operations(
        sync_operations: Dict[str, Callable],
        async_operations: Dict[str, Callable],
        descriptions: Dict[str, str],
        models: Dict[str, BaseModel],
    ) -> List:
        """Get the tools in the toolkit."""
        # Note - we don't yet support Tools with only async operations.
        for name in sync_operations:
            # TODO: Need to include the tool for how to create the request body itself.
            # from the generated BaseModel objects. Should use an
            # we need to add the function signature to the description.
            str_preprocessor = OpenAPIToolkitV2._get_str_preprocessor(
                sync_operations[name], models
            )
            description = descriptions.get(name, "")
            function_signature_string = OpenAPIToolkitV2._get_signature_str(
                sync_operations[name], models
            )
            description += f"\n\n{function_signature_string}"
            sync_fn = OpenAPIToolkitV2._get_composed_function(
                str_preprocessor, sync_operations[name]
            )
            coroutine_fn = (
                OpenAPIToolkitV2._get_composed_function(
                    str_preprocessor, async_operations[name]
                )
                if name in async_operations
                else None
            )
            tool = Tool(
                name=name,
                func=sync_fn,
                coroutine=coroutine_fn,
                description=descriptions.get(name, ""),
            )
            yield tool

    @classmethod
    def from_open_api_spec(
        cls,
        spec_path: Union[str, Path],
        name: str,
        access_token: Optional[str] = None,
        code_dir: Optional[str] = None,
        **kwargs: Any,
    ) -> OpenAPIToolkit:
        """Create json agent from llm, then initialize."""
        spec_path = Path(spec_path)
        code_dir = Path("build") if code_dir is None else Path(code_dir)
        out_dir = code_dir / name
        conversion_result = OpenAPIToolkitV2._generate_data(
            f_name="openai_openapi.yml", out_dir=out_dir
        )
        model_names = [model.file_name for model in conversion_result.models]
        operation_descriptions = {
            op.operation_id: op.operation.summary
            for service in conversion_result.services
            for op in service.operations
        }
        service_file_names = [
            service.file_name for service in conversion_result.services
        ]
        models = OpenAPIToolkitV2._get_openapi_models(name, set(model_names))
        sync_services, async_services = OpenAPIToolkitV2._get_openapi_operations(
            name, set(operation_descriptions), service_file_names
        )

        api_config = OpenAPIToolkitV2._get_api_config(name)
        if access_token:
            api_config.set_access_token(access_token)
        tools = OpenAPIToolkitV2._get_tools_from_operations(
            sync_services, async_services, operation_descriptions, models
        )
        return cls(
            models=models,
            tools=tools,
            api_config=api_config,
        )
